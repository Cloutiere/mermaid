import enum
from typing import Optional, List, Any, Dict

# Utilisation des types et outils spécifiques de SQLModel
from sqlmodel import Field, SQLModel, Relationship, UniqueConstraint

# Utilisation des types SQLAlchemy bruts pour des cas spécifiques (TEXT, ENUM natif, JSON)
from sqlalchemy import Column, Text, Enum as SQLEnum, JSON as SQLJSON


# --- Définition des ENUM pour l'intégrité des données ---
class LinkType(str, enum.Enum):
    """
    Type de lien entre deux nœuds, utilisé pour la visualisation dans Mermaid (DDA 4.A).
    """
    VISIBLE = "VISIBLE"
    INVISIBLE = "INVISIBLE"


# --- 1. Modèle Project (Saga) ---
class Project(SQLModel, table=True):
    """
    Conteneur de haut niveau pour l'ensemble des subprojects.
    """
    id: Optional[int] = Field(default=None, primary_key=True)
    # Réf. DDA 4.A : 'title'
    title: str = Field(index=True, max_length=255) 

    # Relations
    subprojects: List["SubProject"] = Relationship(back_populates="project")


# --- 2. Modèle SubProject (Livre / Graphe Narratif) ---
class SubProject(SQLModel, table=True):
    """
    Représente un unique graphe narratif.
    """
    id: Optional[int] = Field(default=None, primary_key=True)
    project_id: int = Field(foreign_key="project.id", index=True)
    title: str = Field(index=True, max_length=255)
    
    # Stocke la définition Mermaid brute (Non listée explicitement dans 4.A mais fondamentale)
    mermaid_definition: str = Field(sa_column=Column(Text)) 
    
    # DDA 5 : Stocke les métadonnées de disposition visuelle (JSON)
    visual_layout: Optional[Dict[str, Any]] = Field(default=None, sa_column=Column(SQLJSON))

    # Relations
    project: Project = Relationship(back_populates="subprojects")

    # Cascades : Si SubProject est supprimé, tous ses composants le sont aussi.
    nodes: List["Node"] = Relationship(back_populates="subproject", cascade="all, delete-orphan")
    relationships: List["Relationship"] = Relationship(back_populates="subproject", cascade="all, delete-orphan")
    class_defs: List["ClassDef"] = Relationship(back_populates="subproject", cascade="all, delete-orphan")


# --- 3. Modèle Node (Paragraphe / Unité du Graphe) ---
class Node(SQLModel, table=True):
    """
    Représente un nœud individuel dans un subproject.
    """
    id: Optional[int] = Field(default=None, primary_key=True)
    subproject_id: int = Field(foreign_key="subproject.id", index=True)
    
    # Réf. DDA 4.A : mermaid_id (ex: A, B, C1)
    mermaid_id: str = Field(max_length=50) 
    # Réf. DDA 4.A : title, text_content, style_class_ref
    title: Optional[str] = Field(default=None, max_length=255) 
    text_content: str = Field(sa_column=Column(Text))
    style_class_ref: Optional[str] = Field(default=None, max_length=100)

    # Contrainte d'unicité composée : mermaid_id doit être unique au sein du même subproject
    __table_args__ = (UniqueConstraint("subproject_id", "mermaid_id"),)

    # Relations
    subproject: SubProject = Relationship(back_populates="nodes")

    # Relations où ce nœud est la source ou la cible.
    source_relationships: List["Relationship"] = Relationship(
        back_populates="source_node",
        foreign_key="relationship.source_node_id",
        # La suppression d'un nœud supprime les relations associées
        cascade="all, delete-orphan" 
    )
    target_relationships: List["Relationship"] = Relationship(
        back_populates="target_node",
        foreign_key="relationship.target_node_id",
        # La suppression d'un nœud supprime les relations associées
        cascade="all, delete-orphan"
    )


# --- 4. Modèle Relationship (Lien entre Nœuds) ---
class Relationship(SQLModel, table=True):
    """
    Représente un lien dirigé entre deux nœuds.
    """
    id: Optional[int] = Field(default=None, primary_key=True)
    subproject_id: int = Field(foreign_key="subproject.id", index=True)
    
    # Clés étrangères vers la table Node.
    source_node_id: int = Field(foreign_key="node.id", index=True)
    target_node_id: int = Field(foreign_key="node.id", index=True)

    # Réf. DDA 4.A : label (TEXT) et color (String)
    label: Optional[str] = Field(default=None, sa_column=Column(Text))
    color: Optional[str] = Field(default=None, max_length=20) 

    # Réf. DDA 4.A : link_type (ENUM natif PostgreSQL)
    link_type: LinkType = Field(sa_column=Column(SQLEnum(LinkType, name="link_type_enum"), nullable=False))

    # Relations
    subproject: SubProject = Relationship(back_populates="relationships")
    
    source_node: Node = Relationship(
        back_populates="source_relationships",
        foreign_key=[source_node_id] 
    )
    target_node: Node = Relationship(
        back_populates="target_relationships",
        foreign_key=[target_node_id] 
    )


# --- 5. Modèle ClassDef (Définition de Style Mermaid) ---
class ClassDef(SQLModel, table=True):
    """
    Définit des styles ou des classes utilisés dans le graphe.
    """
    id: Optional[int] = Field(default=None, primary_key=True)
    subproject_id: int = Field(foreign_key="subproject.id", index=True)
    # Réf. DDA 4.A : name et definition_raw
    name: str = Field(max_length=100)
    definition_raw: str = Field(sa_column=Column(Text)) 

    # Contrainte d'unicité composée : name doit être unique au sein du même subproject
    __table_args__ = (UniqueConstraint("subproject_id", "name"),)

    # Relations
    subproject: SubProject = Relationship(back_populates="class_defs")